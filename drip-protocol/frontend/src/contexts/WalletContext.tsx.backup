/**
 * DRIP Protocol - Wallet Context
 * 
 * Provides wallet connection state and methods using @stacks/connect v8.x.
 * Per Stacks docs: Uses request('getAddresses') for wallet connection with automatic persistence.
 */

import React, { 
  createContext, 
  useContext, 
  useState, 
  useCallback, 
  useEffect,
  useMemo,
} from "react";
import { 
  request,
  disconnect as stacksDisconnect, 
  isConnected as checkConnected,
  getLocalStorage,
} from "@stacks/connect";
import { 
  getBalances, 
  satsToSbtc, 
  microStxToStx,
  BALANCE_POLL_INTERVAL,
  TESTNET_FAUCET_URL,
  parseWalletError,
  validateStacksAddress,
} from "@/lib/stacks";

// ============================================
// Types
// ============================================

interface WalletState {
  connected: boolean;
  address: string | null;
  stxBalance: bigint;
  sbtcBalance: bigint;
  isLoading: boolean;
  error: string | null;
}

interface WalletContextType extends WalletState {
  // Actions
  connectWallet: () => Promise<void>;
  disconnectWallet: () => void;
  refreshBalances: () => Promise<void>;
  // Computed values
  stxBalanceFormatted: number;
  sbtcBalanceFormatted: number;
  shortAddress: string | null;
  faucetUrl: string;
}

// ============================================
// Context
// ============================================

const WalletContext = createContext<WalletContextType | null>(null);

// ============================================
// Provider
// ============================================

export function WalletProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<WalletState>({
    connected: false,
    address: null,
    stxBalance: 0n,
    sbtcBalance: 0n,
    isLoading: true,
    error: null,
  });

  // Check if already connected on mount
  // Per Stacks docs v8.x: request() with enableLocalStorage:true (default) persists connection
  useEffect(() => {
    const checkExistingConnection = async () => {
      try {
        // Per Stacks docs: isConnected() checks if addresses are stored in localStorage
        const connected = checkConnected();
        console.log('[Wallet] isConnected():', connected);
        
        if (!connected) {
          console.log('[Wallet] No existing session found');
          setState(prev => ({ ...prev, isLoading: false }));
          return;
        }

        // If connected, get the stored addresses from localStorage
        const stored = getLocalStorage();
        console.log('[Wallet] Restoring session from localStorage:', stored);
        
        // Per Stacks docs v8.x: addresses format is { stx: [...], btc: [...] }
        const stxAddress = stored?.addresses?.stx?.[0]?.address;
        
        // Validate we got a testnet address (starts with ST)
        if (!stxAddress || !stxAddress.startsWith('ST')) {
          console.log('[Wallet] No valid testnet address found');
          setState(prev => ({ ...prev, isLoading: false }));
          return;
        }

        console.log('[Wallet] Restoring testnet session for:', stxAddress);
        
        // Restore connection state
        setState(prev => ({
          ...prev,
          connected: true,
          address: stxAddress,
          isLoading: false,
        }));
        
        // Fetch balances in background
        try {
          const balances = await getBalances(stxAddress);
          setState(prev => ({
            ...prev,
            stxBalance: balances.stx,
            sbtcBalance: balances.sbtc,
          }));
        } catch (balanceError) {
          console.error('[Wallet] Error fetching balances:', balanceError);
        }
      } catch (error) {
        console.error('[Wallet] Error checking existing connection:', error);
        setState(prev => ({ ...prev, isLoading: false }));
      }
    };

    checkExistingConnection();
  }, []);

  // Poll for balance updates
  useEffect(() => {
    if (!state.address) return;

    const pollBalances = async () => {
      try {
        const balances = await getBalances(state.address!);
        setState(prev => ({
          ...prev,
          stxBalance: balances.stx,
          sbtcBalance: balances.sbtc,
        }));
      } catch (error) {
        console.error("Error polling balances:", error);
      }
    };

    const interval = setInterval(pollBalances, BALANCE_POLL_INTERVAL);
    return () => clearInterval(interval);
  }, [state.address]);

  /**
   * Connect wallet using @stacks/connect
   * Per Stacks docs: connect() initiates wallet connection and stores addresses
   */
  const connectWallet = useCallback(async () => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Per Stacks docs: connect() with options
      const response = await connect();
      console.log('[Wallet] Connect respo v8.x
   * Per Stacks docs: request('getAddresses') with enableLocalStorage:true (default) persists connection
   */
  const connectWallet = useCallback(async () => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Per Stacks docs v8.x: Use request('getAddresses') instead of connect()
      // enableLocalStorage: true is default, which persists addresses to localStorage
      const response = await request('getAddresses');
      console.log('[Wallet] getAddresses response:', response);

      // Per Stacks docs v8.x: response format is array of address objects
      // Find the STX address (symbol: 'STX')
      const stxAddressObj = response.addresses?.find((addr: any) => addr.symbol === 'STX');
      const userAddress = stxAddressObj?.address;
      
      // Validate we got
      setState({
        connected: true,
        address: userAddress,
        stxBalance: balances.stx,
        sbtcBalance: balances.sbtc,
        isLoading: false,
        error: null,
      });
    } catch (error) {
      // Per Stacks docs: Use standard error handling pattern
      const message = parseWalletError(error);
      console.error("[Wallet] Connection error:", error);
      setState(prev => ({
        ...prev,
        connected: false,
        address: null,
        isLoading: false,
        error: message,
      }));
    }
  }, []);

  /**
   * Disconnect wallet
   * Per Stacks docs: disconnect() clears stored session
   */
  const disconnectWallet = useCallback(() => {
    stacksDisconnect();
    setState({
      connected: false,
      address: null,
      stxBalance: 0n,
      sbtcBalance: 0n,
      isLoading: false,
      error: null,
    });
  }, []);

  /**
   * Manually refresh balances
   */
  const refreshBalances = useCallback(async () => {
    if (!state.address) return;

    try {
      const balances = await getBalances(state.address);
      setState(prev => ({
        ...prev,
        stxBalance: balances.stx,
        sbtcBalance: balances.sbtc,
      }));
    } catch (error) {
      console.error("Error refreshing balances:", error);
    }
  }, [state.address]);

  // Computed values
  const stxBalanceFormatted = useMemo(
    () => microStxToStx(state.stxBalance),
    [state.stxBalance]
  );

  const sbtcBalanceFormatted = useMemo(
    () => satsToSbtc(state.sbtcBalance),
    [state.sbtcBalance]
  );

  const shortAddress = useMemo(() => {
    if (!state.address) return null;
    return `${state.address.slice(0, 6)}...${state.address.slice(-4)}`;
  }, [state.address]);

  const value = useMemo(
    () => ({
      ...state,
      connectWallet,
      disconnectWallet,
      refreshBalances,
      stxBalanceFormatted,
      sbtcBalanceFormatted,
      shortAddress,
      faucetUrl: TESTNET_FAUCET_URL,
    }),
    [
      state,
      connectWallet,
      disconnectWallet,
      refreshBalances,
      stxBalanceFormatted,
      sbtcBalanceFormatted,
      shortAddress,
    ]
  );

  return (
    <WalletContext.Provider value={value}>
      {children}
    </WalletContext.Provider>
  );
}

// ============================================
// Hook
// ============================================

export function useWallet() {
  const ctx = useContext(WalletContext);
  if (!ctx) {
    throw new Error("useWallet must be used within WalletProvider");
  }
  return ctx;
}
